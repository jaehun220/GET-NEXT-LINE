# 📘 Get Next Line

파일 디스크립터에서 한 줄씩 읽어오는 함수를 직접 구현하는 42 과제입니다.  
정적 변수(static variable)의 개념을 배우고, 효율적인 파일 입출력을 구현하는 데 집중합니다.

---

## 🎯 목표 (Goals)

- `get_next_line()`이라는 함수를 작성하여 파일 디스크립터로부터 한 줄씩 읽어오는 기능 구현
- 반복 호출을 통해 텍스트 파일의 모든 줄을 순차적으로 반환
- 정적 변수의 개념을 익히고 실전에서 활용

---

## 📜 공통 규칙 (Common Instructions)

- 모든 코드는 **C 언어**로 작성되어야 합니다.
- **Norminette** 스타일 가이드를 반드시 준수해야 합니다.
- 예기치 않은 종료 (세그폴트, 버스 에러, double free 등)는 평가에서 0점 처리됩니다.
- **메모리 누수는 허용되지 않습니다.**
- `Makefile`에는 최소 다음 규칙이 있어야 합니다:
  - `$(NAME)`
  - `all`
  - `clean`
  - `fclean`
  - `re`
- 보너스 파일은 `_bonus.c`, `_bonus.h` 형식으로 제출해야 하며, `Makefile`에 `bonus` 규칙이 포함되어야 합니다.
- `libft` 사용이 허용된 경우, 소스를 복사해서 `libft` 폴더에 포함시키고 해당 Makefile을 통해 빌드해야 합니다.
- 평가 대상은 Git 레포지토리에 존재하는 파일만 해당됩니다.

---

## 📂 필수 구현 (Mandatory Part)

| 항목 | 내용 |
|------|------|
| 함수 이름 | `get_next_line` |
| 프로토타입 | `char *get_next_line(int fd);` |
| 반환값 | 한 줄 문자열(`\n` 포함), 더 이상 읽을 것이 없거나 오류 발생 시 `NULL` |
| 외부 함수 | `read`, `malloc`, `free` |
| 제출 파일 | `get_next_line.c`, `get_next_line_utils.c`, `get_next_line.h` |

### 🔧 구현 조건

- 파일과 표준 입력에서 모두 정상 작동해야 합니다.
- 반환 문자열에는 `\n`을 포함해야 합니다 (파일이 `\n`으로 끝나지 않는 경우 제외).
- 반복 호출 시 다음 줄을 반환해야 하며, EOF나 오류 발생 시 `NULL` 반환
- `BUFFER_SIZE`는 `-D BUFFER_SIZE=<숫자>`로 컴파일 시 정의해야 합니다.
  - 예시:  
    ```bash
    cc -Wall -Wextra -Werror -D BUFFER_SIZE=42 *.c
    ```

### 🚫 금지사항

- `libft` 사용 금지
- `lseek()` 사용 금지
- 전역 변수 금지

---

## 🎁 보너스 (Bonus Part)

> 보너스는 필수 파트를 **완벽히 구현했을 경우에만** 평가됩니다.

### 요구 사항

- **단 하나의 static 변수**만 사용하여 구현
- **여러 개의 파일 디스크립터(fd)**를 동시에 지원해야 함

### 보너스 제출 파일

- `get_next_line_bonus.c`
- `get_next_line_bonus.h`
- `get_next_line_utils_bonus.c`

---

## 🚀 제출 및 평가

- Git 레포지토리에 올린 내용만 평가됩니다.
- 평가자는 다양한 상황을 테스트할 수 있습니다:
  - 다양한 `BUFFER_SIZE` 값 (1, 42, 9999, 10000000 등)
  - 긴 줄, 빈 줄, 파일 끝에 `\n` 없는 경우 등
  - 표준 입력 및 여러 파일 디스크립터 사용

### 💡 팁

- 테스트 코드를 직접 작성하여 다양한 입력을 시뮬레이션해보세요.
- 디펜스 시 본인의 테스트 코드와 동료의 코드를 자유롭게 사용할 수 있습니다.

---

## 🧠 질문 유도

- `static` 변수를 왜 써야 할까요?
- `BUFFER_SIZE`가 작거나 클 경우 동작에 어떤 영향을 줄까요?
- 여러 fd를 동시에 처리할 때 상태를 어떻게 구분해야 할까요?

